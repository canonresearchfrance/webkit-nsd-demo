/* This file has been automatically generated by geneet.py */
/*                      DO NOT MODIFY                      */

#include <limits.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include "eve_state.h"

struct _Config {
    unsigned char allow_popup;
    unsigned char enable_auto_load_images;
    unsigned char enable_auto_shrink_images;
    unsigned char enable_javascript;
    unsigned char enable_mouse_cursor;
    unsigned char enable_plugins;
    unsigned char enable_private_mode;
    unsigned char enable_touch_interface;
    unsigned char enable_auto_network_access;
    const char * home_page;
    const char * proxy;
    unsigned char restore_state;
    const char * user_agent;
    unsigned char frame_flattening;
    int text_zoom;
    int minimum_font_size;
    int cookie_policy;
    int backing_store;
    const char *__eet_filename;
};

struct _Hist_Item {
    const char * title;
    const char * url;
    unsigned int visit_count;
    double last_visit;
};

struct _Hist {
    Eina_Hash * items;
    const char *__eet_filename;
};

struct _Fav_Item {
    const char * url;
    const char * title;
    unsigned int visit_count;
};

struct _Fav {
    Eina_Hash * items;
    const char *__eet_filename;
};

struct _Session_Item {
    const char * url;
    unsigned char focused;
    int scroll_x;
    int scroll_y;
};

struct _Session_Window {
    Eina_List * tabs;
    unsigned char focused;
};

struct _Session {
    Eina_List * windows;
    const char *__eet_filename;
};

struct _Services {
    const char * id;
    const char * model;
    const char * types;
    Evas_Object * icon;
    unsigned int icon__id;
    unsigned char allowed;
};

struct _Device {
    const char * url;
    const char * friendly_name;
    Evas_Object * icon;
    unsigned int icon__id;
    unsigned char allowed;
    Eina_Hash * services;
};

struct _Network_Origin {
    const char * origin;
    Eina_List * devices;
    Eina_Hash * services;
};

struct _Network {
    Eina_List * origins;
    const char *__eet_filename;
};

static const char CONFIG_ENTRY[] = "config";
static const char HIST_ENTRY[] = "hist";
static const char FAV_ENTRY[] = "fav";
static const char SESSION_ENTRY[] = "session";
static const char NETWORK_ENTRY[] = "network";

static Eet_Data_Descriptor *_config_descriptor = NULL;
static Eet_Data_Descriptor *_hist_item_descriptor = NULL;
static Eet_Data_Descriptor *_hist_descriptor = NULL;
static Eet_Data_Descriptor *_fav_item_descriptor = NULL;
static Eet_Data_Descriptor *_fav_descriptor = NULL;
static Eet_Data_Descriptor *_session_item_descriptor = NULL;
static Eet_Data_Descriptor *_session_window_descriptor = NULL;
static Eet_Data_Descriptor *_session_descriptor = NULL;
static Eet_Data_Descriptor *_services_descriptor = NULL;
static Eet_Data_Descriptor *_device_descriptor = NULL;
static Eet_Data_Descriptor *_network_origin_descriptor = NULL;
static Eet_Data_Descriptor *_network_descriptor = NULL;

static unsigned int _images_id = 1;

static inline void
_config_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_config_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Config);
    _config_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "allow_popup", allow_popup, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "enable_auto_load_images", enable_auto_load_images, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "enable_auto_shrink_images", enable_auto_shrink_images, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "enable_javascript", enable_javascript, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "enable_mouse_cursor", enable_mouse_cursor, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "enable_plugins", enable_plugins, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "enable_private_mode", enable_private_mode, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "enable_touch_interface", enable_touch_interface, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "enable_auto_network_access", enable_auto_network_access, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "home_page", home_page, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "proxy", proxy, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "restore_state", restore_state, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "user_agent", user_agent, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "frame_flattening", frame_flattening, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "text_zoom", text_zoom, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "minimum_font_size", minimum_font_size, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "cookie_policy", cookie_policy, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_config_descriptor, Config, "backing_store", backing_store, EET_T_INT);
}

static inline void
_config_shutdown(void)
{
    if (!_config_descriptor) return;
    eet_data_descriptor_free(_config_descriptor);
    _config_descriptor = NULL;
}

Config *
config_new(unsigned char allow_popup, unsigned char enable_auto_load_images, unsigned char enable_auto_shrink_images, unsigned char enable_javascript, unsigned char enable_mouse_cursor, unsigned char enable_plugins, unsigned char enable_private_mode, unsigned char enable_touch_interface, unsigned char enable_auto_network_access, const char * home_page, const char * proxy, unsigned char restore_state, const char * user_agent, unsigned char frame_flattening, int text_zoom, int minimum_font_size, int cookie_policy, int backing_store)
{
    Config *config = calloc(1, sizeof(Config));

    if (!config)
       {
          fprintf(stderr, "ERROR: could not calloc Config\n");
          return NULL;
       }

    config->allow_popup = allow_popup;
    config->enable_auto_load_images = enable_auto_load_images;
    config->enable_auto_shrink_images = enable_auto_shrink_images;
    config->enable_javascript = enable_javascript;
    config->enable_mouse_cursor = enable_mouse_cursor;
    config->enable_plugins = enable_plugins;
    config->enable_private_mode = enable_private_mode;
    config->enable_touch_interface = enable_touch_interface;
    config->enable_auto_network_access = enable_auto_network_access;
    config->home_page = eina_stringshare_add(home_page ? home_page : "http://www.google.com");
    config->proxy = eina_stringshare_add(proxy);
    config->restore_state = restore_state;
    config->user_agent = eina_stringshare_add(user_agent ? user_agent : "eve");
    config->frame_flattening = frame_flattening;
    config->text_zoom = text_zoom;
    config->minimum_font_size = minimum_font_size;
    config->cookie_policy = cookie_policy;
    config->backing_store = backing_store;

    return config;
}

void
config_free(Config *config)
{
    eina_stringshare_del(config->home_page);
    eina_stringshare_del(config->proxy);
    eina_stringshare_del(config->user_agent);
    free(config);
}

inline unsigned char
config_allow_popup_get(const Config *config)
{
    return config->allow_popup;
}

inline void
config_allow_popup_set(Config *config, unsigned char allow_popup)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->allow_popup = allow_popup;
}

inline unsigned char
config_enable_auto_load_images_get(const Config *config)
{
    return config->enable_auto_load_images;
}

inline void
config_enable_auto_load_images_set(Config *config, unsigned char enable_auto_load_images)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->enable_auto_load_images = enable_auto_load_images;
}

inline unsigned char
config_enable_auto_shrink_images_get(const Config *config)
{
    return config->enable_auto_shrink_images;
}

inline void
config_enable_auto_shrink_images_set(Config *config, unsigned char enable_auto_shrink_images)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->enable_auto_shrink_images = enable_auto_shrink_images;
}

inline unsigned char
config_enable_javascript_get(const Config *config)
{
    return config->enable_javascript;
}

inline void
config_enable_javascript_set(Config *config, unsigned char enable_javascript)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->enable_javascript = enable_javascript;
}

inline unsigned char
config_enable_mouse_cursor_get(const Config *config)
{
    return config->enable_mouse_cursor;
}

inline void
config_enable_mouse_cursor_set(Config *config, unsigned char enable_mouse_cursor)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->enable_mouse_cursor = enable_mouse_cursor;
}

inline unsigned char
config_enable_plugins_get(const Config *config)
{
    return config->enable_plugins;
}

inline void
config_enable_plugins_set(Config *config, unsigned char enable_plugins)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->enable_plugins = enable_plugins;
}

inline unsigned char
config_enable_private_mode_get(const Config *config)
{
    return config->enable_private_mode;
}

inline void
config_enable_private_mode_set(Config *config, unsigned char enable_private_mode)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->enable_private_mode = enable_private_mode;
}

inline unsigned char
config_enable_touch_interface_get(const Config *config)
{
    return config->enable_touch_interface;
}

inline void
config_enable_touch_interface_set(Config *config, unsigned char enable_touch_interface)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->enable_touch_interface = enable_touch_interface;
}

inline unsigned char
config_enable_auto_network_access_get(const Config *config)
{
    return config->enable_auto_network_access;
}

inline void
config_enable_auto_network_access_set(Config *config, unsigned char enable_auto_network_access)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->enable_auto_network_access = enable_auto_network_access;
}

inline const char *
config_home_page_get(const Config *config)
{
    return config->home_page;
}

inline void
config_home_page_set(Config *config, const char *home_page)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    eina_stringshare_replace(&(config->home_page), home_page);
}

inline const char *
config_proxy_get(const Config *config)
{
    return config->proxy;
}

inline void
config_proxy_set(Config *config, const char *proxy)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    eina_stringshare_replace(&(config->proxy), proxy);
}

inline unsigned char
config_restore_state_get(const Config *config)
{
    return config->restore_state;
}

inline void
config_restore_state_set(Config *config, unsigned char restore_state)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->restore_state = restore_state;
}

inline const char *
config_user_agent_get(const Config *config)
{
    return config->user_agent;
}

inline void
config_user_agent_set(Config *config, const char *user_agent)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    eina_stringshare_replace(&(config->user_agent), user_agent);
}

inline unsigned char
config_frame_flattening_get(const Config *config)
{
    return config->frame_flattening;
}

inline void
config_frame_flattening_set(Config *config, unsigned char frame_flattening)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->frame_flattening = frame_flattening;
}

inline int
config_text_zoom_get(const Config *config)
{
    return config->text_zoom;
}

inline void
config_text_zoom_set(Config *config, int text_zoom)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->text_zoom = text_zoom;
}

inline int
config_minimum_font_size_get(const Config *config)
{
    return config->minimum_font_size;
}

inline void
config_minimum_font_size_set(Config *config, int minimum_font_size)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->minimum_font_size = minimum_font_size;
}

inline int
config_cookie_policy_get(const Config *config)
{
    return config->cookie_policy;
}

inline void
config_cookie_policy_set(Config *config, int cookie_policy)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->cookie_policy = cookie_policy;
}

inline int
config_backing_store_get(const Config *config)
{
    return config->backing_store;
}

inline void
config_backing_store_set(Config *config, int backing_store)
{
    EINA_SAFETY_ON_NULL_RETURN(config);
    config->backing_store = backing_store;
}

Config *
config_load(const char *filename)
{
    Config *config = NULL;
    Eet_File *ef = eet_open(filename, EET_FILE_MODE_READ);
    if (!ef)
      {
        fprintf(stderr, "ERROR: could not open '%s' for read\n", filename);
        return NULL;
      }

    config = eet_data_read(ef, _config_descriptor, CONFIG_ENTRY);
    if (!config) goto end;
    config->__eet_filename = eina_stringshare_add(filename);

end:
    eet_close(ef);
    return config;
}

Eina_Bool
config_save(Config *config, const char *filename)
{
    Eet_File *ef;
    Eina_Bool ret;

    if (filename) eina_stringshare_replace(&(config->__eet_filename), filename);
    else if (config->__eet_filename) filename = config->__eet_filename;
    else return EINA_FALSE;

    ef = eet_open(filename, EET_FILE_MODE_READ_WRITE);
    if (!ef)
       {
          fprintf(stderr, "ERROR: could not open '%s' for write\n", filename);
          return EINA_FALSE;
       }

    ret = !!eet_data_write(ef, _config_descriptor, CONFIG_ENTRY, config, EINA_TRUE);
    eet_close(ef);

    return ret;
}

static inline void
_hist_item_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_hist_item_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Hist_Item);
    _hist_item_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_hist_item_descriptor, Hist_Item, "title", title, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_hist_item_descriptor, Hist_Item, "url", url, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_hist_item_descriptor, Hist_Item, "visit_count", visit_count, EET_T_UINT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_hist_item_descriptor, Hist_Item, "last_visit", last_visit, EET_T_DOUBLE);
}

static inline void
_hist_item_shutdown(void)
{
    if (!_hist_item_descriptor) return;
    eet_data_descriptor_free(_hist_item_descriptor);
    _hist_item_descriptor = NULL;
}

Hist_Item *
hist_item_new(const char * title, const char * url, unsigned int visit_count, double last_visit)
{
    Hist_Item *hist_item = calloc(1, sizeof(Hist_Item));

    if (!hist_item)
       {
          fprintf(stderr, "ERROR: could not calloc Hist_Item\n");
          return NULL;
       }

    hist_item->title = eina_stringshare_add(title ? title : "Untitled");
    hist_item->url = eina_stringshare_add(url ? url : "about:blank");
    hist_item->visit_count = visit_count;
    hist_item->last_visit = last_visit;

    return hist_item;
}

void
hist_item_free(Hist_Item *hist_item)
{
    eina_stringshare_del(hist_item->title);
    eina_stringshare_del(hist_item->url);
    free(hist_item);
}

inline const char *
hist_item_title_get(const Hist_Item *hist_item)
{
    return hist_item->title;
}

inline void
hist_item_title_set(Hist_Item *hist_item, const char *title)
{
    EINA_SAFETY_ON_NULL_RETURN(hist_item);
    eina_stringshare_replace(&(hist_item->title), title);
}

inline const char *
hist_item_url_get(const Hist_Item *hist_item)
{
    return hist_item->url;
}

inline void
hist_item_url_set(Hist_Item *hist_item, const char *url)
{
    EINA_SAFETY_ON_NULL_RETURN(hist_item);
    eina_stringshare_replace(&(hist_item->url), url);
}

inline unsigned int
hist_item_visit_count_get(const Hist_Item *hist_item)
{
    return hist_item->visit_count;
}

inline void
hist_item_visit_count_set(Hist_Item *hist_item, unsigned int visit_count)
{
    EINA_SAFETY_ON_NULL_RETURN(hist_item);
    hist_item->visit_count = visit_count;
}

inline double
hist_item_last_visit_get(const Hist_Item *hist_item)
{
    return hist_item->last_visit;
}

inline void
hist_item_last_visit_set(Hist_Item *hist_item, double last_visit)
{
    EINA_SAFETY_ON_NULL_RETURN(hist_item);
    hist_item->last_visit = last_visit;
}


static inline void
_hist_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_hist_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Hist);
    _hist_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_HASH(_hist_descriptor, Hist, "items", items, _hist_item_descriptor);
}

static inline void
_hist_shutdown(void)
{
    if (!_hist_descriptor) return;
    eet_data_descriptor_free(_hist_descriptor);
    _hist_descriptor = NULL;
}

Hist *
hist_new()
{
    Hist *hist = calloc(1, sizeof(Hist));

    if (!hist)
       {
          fprintf(stderr, "ERROR: could not calloc Hist\n");
          return NULL;
       }

    hist->items = eina_hash_stringshared_new(EINA_FREE_CB(hist_item_free));

    return hist;
}

void
hist_free(Hist *hist)
{
    if (hist->items) eina_hash_free(hist->items);
    free(hist);
}

void
hist_items_add(Hist *hist, const char * url, Hist_Item *hist_item)
{
    EINA_SAFETY_ON_NULL_RETURN(hist);
    eina_hash_add(hist->items, url, hist_item);
}

void
hist_items_del(Hist *hist, const char * url)
{
    EINA_SAFETY_ON_NULL_RETURN(hist);
    eina_hash_del(hist->items, url, NULL);
}

inline Hist_Item *
hist_items_get(const Hist *hist, const char * url)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(hist, NULL);
    return eina_hash_find(hist->items, url);
}

inline Eina_Hash *
hist_items_hash_get(const Hist *hist)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(hist, NULL);
    return hist->items;
}

void
hist_items_modify(Hist *hist, const char * key, void *value)
{
    EINA_SAFETY_ON_NULL_RETURN(hist);
    eina_hash_modify(hist->items, key, value);
}

Hist *
hist_load(const char *filename)
{
    Hist *hist = NULL;
    Eet_File *ef = eet_open(filename, EET_FILE_MODE_READ);
    if (!ef)
      {
        fprintf(stderr, "ERROR: could not open '%s' for read\n", filename);
        return NULL;
      }

    hist = eet_data_read(ef, _hist_descriptor, HIST_ENTRY);
    if (!hist) goto end;
    hist->__eet_filename = eina_stringshare_add(filename);

    if (!hist->items) hist->items = eina_hash_stringshared_new(EINA_FREE_CB(hist_item_free));

end:
    eet_close(ef);
    return hist;
}

Eina_Bool
hist_save(Hist *hist, const char *filename)
{
    Eet_File *ef;
    Eina_Bool ret;

    if (filename) eina_stringshare_replace(&(hist->__eet_filename), filename);
    else if (hist->__eet_filename) filename = hist->__eet_filename;
    else return EINA_FALSE;

    ef = eet_open(filename, EET_FILE_MODE_READ_WRITE);
    if (!ef)
       {
          fprintf(stderr, "ERROR: could not open '%s' for write\n", filename);
          return EINA_FALSE;
       }

    ret = !!eet_data_write(ef, _hist_descriptor, HIST_ENTRY, hist, EINA_TRUE);
    eet_close(ef);

    return ret;
}

static inline void
_fav_item_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_fav_item_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Fav_Item);
    _fav_item_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_fav_item_descriptor, Fav_Item, "url", url, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_fav_item_descriptor, Fav_Item, "title", title, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_fav_item_descriptor, Fav_Item, "visit_count", visit_count, EET_T_UINT);
}

static inline void
_fav_item_shutdown(void)
{
    if (!_fav_item_descriptor) return;
    eet_data_descriptor_free(_fav_item_descriptor);
    _fav_item_descriptor = NULL;
}

Fav_Item *
fav_item_new(const char * url, const char * title, unsigned int visit_count)
{
    Fav_Item *fav_item = calloc(1, sizeof(Fav_Item));

    if (!fav_item)
       {
          fprintf(stderr, "ERROR: could not calloc Fav_Item\n");
          return NULL;
       }

    fav_item->url = eina_stringshare_add(url);
    fav_item->title = eina_stringshare_add(title);
    fav_item->visit_count = visit_count;

    return fav_item;
}

void
fav_item_free(Fav_Item *fav_item)
{
    eina_stringshare_del(fav_item->url);
    eina_stringshare_del(fav_item->title);
    free(fav_item);
}

inline const char *
fav_item_url_get(const Fav_Item *fav_item)
{
    return fav_item->url;
}

inline void
fav_item_url_set(Fav_Item *fav_item, const char *url)
{
    EINA_SAFETY_ON_NULL_RETURN(fav_item);
    eina_stringshare_replace(&(fav_item->url), url);
}

inline const char *
fav_item_title_get(const Fav_Item *fav_item)
{
    return fav_item->title;
}

inline void
fav_item_title_set(Fav_Item *fav_item, const char *title)
{
    EINA_SAFETY_ON_NULL_RETURN(fav_item);
    eina_stringshare_replace(&(fav_item->title), title);
}

inline unsigned int
fav_item_visit_count_get(const Fav_Item *fav_item)
{
    return fav_item->visit_count;
}

inline void
fav_item_visit_count_set(Fav_Item *fav_item, unsigned int visit_count)
{
    EINA_SAFETY_ON_NULL_RETURN(fav_item);
    fav_item->visit_count = visit_count;
}


static inline void
_fav_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_fav_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Fav);
    _fav_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_HASH(_fav_descriptor, Fav, "items", items, _fav_item_descriptor);
}

static inline void
_fav_shutdown(void)
{
    if (!_fav_descriptor) return;
    eet_data_descriptor_free(_fav_descriptor);
    _fav_descriptor = NULL;
}

Fav *
fav_new()
{
    Fav *fav = calloc(1, sizeof(Fav));

    if (!fav)
       {
          fprintf(stderr, "ERROR: could not calloc Fav\n");
          return NULL;
       }

    fav->items = eina_hash_stringshared_new(EINA_FREE_CB(fav_item_free));

    return fav;
}

void
fav_free(Fav *fav)
{
    if (fav->items) eina_hash_free(fav->items);
    free(fav);
}

void
fav_items_add(Fav *fav, const char * url, Fav_Item *fav_item)
{
    EINA_SAFETY_ON_NULL_RETURN(fav);
    eina_hash_add(fav->items, url, fav_item);
}

void
fav_items_del(Fav *fav, const char * url)
{
    EINA_SAFETY_ON_NULL_RETURN(fav);
    eina_hash_del(fav->items, url, NULL);
}

inline Fav_Item *
fav_items_get(const Fav *fav, const char * url)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(fav, NULL);
    return eina_hash_find(fav->items, url);
}

inline Eina_Hash *
fav_items_hash_get(const Fav *fav)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(fav, NULL);
    return fav->items;
}

void
fav_items_modify(Fav *fav, const char * key, void *value)
{
    EINA_SAFETY_ON_NULL_RETURN(fav);
    eina_hash_modify(fav->items, key, value);
}

Fav *
fav_load(const char *filename)
{
    Fav *fav = NULL;
    Eet_File *ef = eet_open(filename, EET_FILE_MODE_READ);
    if (!ef)
      {
        fprintf(stderr, "ERROR: could not open '%s' for read\n", filename);
        return NULL;
      }

    fav = eet_data_read(ef, _fav_descriptor, FAV_ENTRY);
    if (!fav) goto end;
    fav->__eet_filename = eina_stringshare_add(filename);

    if (!fav->items) fav->items = eina_hash_stringshared_new(EINA_FREE_CB(fav_item_free));

end:
    eet_close(ef);
    return fav;
}

Eina_Bool
fav_save(Fav *fav, const char *filename)
{
    Eet_File *ef;
    Eina_Bool ret;

    if (filename) eina_stringshare_replace(&(fav->__eet_filename), filename);
    else if (fav->__eet_filename) filename = fav->__eet_filename;
    else return EINA_FALSE;

    ef = eet_open(filename, EET_FILE_MODE_READ_WRITE);
    if (!ef)
       {
          fprintf(stderr, "ERROR: could not open '%s' for write\n", filename);
          return EINA_FALSE;
       }

    ret = !!eet_data_write(ef, _fav_descriptor, FAV_ENTRY, fav, EINA_TRUE);
    eet_close(ef);

    return ret;
}

static inline void
_session_item_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_session_item_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Session_Item);
    _session_item_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_session_item_descriptor, Session_Item, "url", url, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_session_item_descriptor, Session_Item, "focused", focused, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_session_item_descriptor, Session_Item, "scroll_x", scroll_x, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_session_item_descriptor, Session_Item, "scroll_y", scroll_y, EET_T_INT);
}

static inline void
_session_item_shutdown(void)
{
    if (!_session_item_descriptor) return;
    eet_data_descriptor_free(_session_item_descriptor);
    _session_item_descriptor = NULL;
}

Session_Item *
session_item_new(const char * url, unsigned char focused, int scroll_x, int scroll_y)
{
    Session_Item *session_item = calloc(1, sizeof(Session_Item));

    if (!session_item)
       {
          fprintf(stderr, "ERROR: could not calloc Session_Item\n");
          return NULL;
       }

    session_item->url = eina_stringshare_add(url);
    session_item->focused = focused;
    session_item->scroll_x = scroll_x;
    session_item->scroll_y = scroll_y;

    return session_item;
}

void
session_item_free(Session_Item *session_item)
{
    eina_stringshare_del(session_item->url);
    free(session_item);
}

inline const char *
session_item_url_get(const Session_Item *session_item)
{
    return session_item->url;
}

inline void
session_item_url_set(Session_Item *session_item, const char *url)
{
    EINA_SAFETY_ON_NULL_RETURN(session_item);
    eina_stringshare_replace(&(session_item->url), url);
}

inline unsigned char
session_item_focused_get(const Session_Item *session_item)
{
    return session_item->focused;
}

inline void
session_item_focused_set(Session_Item *session_item, unsigned char focused)
{
    EINA_SAFETY_ON_NULL_RETURN(session_item);
    session_item->focused = focused;
}

inline int
session_item_scroll_x_get(const Session_Item *session_item)
{
    return session_item->scroll_x;
}

inline void
session_item_scroll_x_set(Session_Item *session_item, int scroll_x)
{
    EINA_SAFETY_ON_NULL_RETURN(session_item);
    session_item->scroll_x = scroll_x;
}

inline int
session_item_scroll_y_get(const Session_Item *session_item)
{
    return session_item->scroll_y;
}

inline void
session_item_scroll_y_set(Session_Item *session_item, int scroll_y)
{
    EINA_SAFETY_ON_NULL_RETURN(session_item);
    session_item->scroll_y = scroll_y;
}


static inline void
_session_window_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_session_window_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Session_Window);
    _session_window_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_LIST(_session_window_descriptor, Session_Window, "tabs", tabs, _session_item_descriptor);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_session_window_descriptor, Session_Window, "focused", focused, EET_T_UCHAR);
}

static inline void
_session_window_shutdown(void)
{
    if (!_session_window_descriptor) return;
    eet_data_descriptor_free(_session_window_descriptor);
    _session_window_descriptor = NULL;
}

Session_Window *
session_window_new(Eina_List * tabs, unsigned char focused)
{
    Session_Window *session_window = calloc(1, sizeof(Session_Window));

    if (!session_window)
       {
          fprintf(stderr, "ERROR: could not calloc Session_Window\n");
          return NULL;
       }

    session_window->tabs = tabs;
    session_window->focused = focused;

    return session_window;
}

void
session_window_free(Session_Window *session_window)
{
    if (session_window->tabs)
       {
          Session_Item *tabs_elem;
          EINA_LIST_FREE(session_window->tabs, tabs_elem)
             session_item_free(tabs_elem);
       }
    free(session_window);
}

inline void
session_window_tabs_add(Session_Window *session_window, Session_Item *session_item)
{
    EINA_SAFETY_ON_NULL_RETURN(session_window);
    session_window->tabs = eina_list_append(session_window->tabs, session_item);
}

inline void
session_window_tabs_del(Session_Window *session_window, Session_Item *session_item)
{
    EINA_SAFETY_ON_NULL_RETURN(session_window);
    session_window->tabs = eina_list_remove(session_window->tabs, session_item);
}

inline Session_Item *
session_window_tabs_get(const Session_Window *session_window, unsigned int nth)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(session_window, NULL);
    return eina_list_nth(session_window->tabs, nth);
}

inline unsigned int
session_window_tabs_count(const Session_Window *session_window)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(session_window, 0);
    return eina_list_count(session_window->tabs);
}

void
session_window_tabs_list_clear(Session_Window *session_window)
{
    EINA_SAFETY_ON_NULL_RETURN(session_window);
    Session_Item *data;
    EINA_LIST_FREE(session_window->tabs, data) session_item_free(data);
}

inline Eina_List *
session_window_tabs_list_get(const Session_Window *session_window)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(session_window, NULL);
    return session_window->tabs;
}

inline void
session_window_tabs_list_set(Session_Window *session_window, Eina_List *list)
{
    EINA_SAFETY_ON_NULL_RETURN(session_window);
    session_window->tabs = list;
}

inline unsigned char
session_window_focused_get(const Session_Window *session_window)
{
    return session_window->focused;
}

inline void
session_window_focused_set(Session_Window *session_window, unsigned char focused)
{
    EINA_SAFETY_ON_NULL_RETURN(session_window);
    session_window->focused = focused;
}


static inline void
_session_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_session_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Session);
    _session_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_LIST(_session_descriptor, Session, "windows", windows, _session_window_descriptor);
}

static inline void
_session_shutdown(void)
{
    if (!_session_descriptor) return;
    eet_data_descriptor_free(_session_descriptor);
    _session_descriptor = NULL;
}

Session *
session_new(Eina_List * windows)
{
    Session *session = calloc(1, sizeof(Session));

    if (!session)
       {
          fprintf(stderr, "ERROR: could not calloc Session\n");
          return NULL;
       }

    session->windows = windows;

    return session;
}

void
session_free(Session *session)
{
    if (session->windows)
       {
          Session_Window *windows_elem;
          EINA_LIST_FREE(session->windows, windows_elem)
             session_window_free(windows_elem);
       }
    free(session);
}

inline void
session_windows_add(Session *session, Session_Window *session_window)
{
    EINA_SAFETY_ON_NULL_RETURN(session);
    session->windows = eina_list_append(session->windows, session_window);
}

inline void
session_windows_del(Session *session, Session_Window *session_window)
{
    EINA_SAFETY_ON_NULL_RETURN(session);
    session->windows = eina_list_remove(session->windows, session_window);
}

inline Session_Window *
session_windows_get(const Session *session, unsigned int nth)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(session, NULL);
    return eina_list_nth(session->windows, nth);
}

inline unsigned int
session_windows_count(const Session *session)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(session, 0);
    return eina_list_count(session->windows);
}

void
session_windows_list_clear(Session *session)
{
    EINA_SAFETY_ON_NULL_RETURN(session);
    Session_Window *data;
    EINA_LIST_FREE(session->windows, data) session_window_free(data);
}

inline Eina_List *
session_windows_list_get(const Session *session)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(session, NULL);
    return session->windows;
}

inline void
session_windows_list_set(Session *session, Eina_List *list)
{
    EINA_SAFETY_ON_NULL_RETURN(session);
    session->windows = list;
}

Session *
session_load(const char *filename)
{
    Session *session = NULL;
    Eet_File *ef = eet_open(filename, EET_FILE_MODE_READ);
    if (!ef)
      {
        fprintf(stderr, "ERROR: could not open '%s' for read\n", filename);
        return NULL;
      }

    session = eet_data_read(ef, _session_descriptor, SESSION_ENTRY);
    if (!session) goto end;
    session->__eet_filename = eina_stringshare_add(filename);

end:
    eet_close(ef);
    return session;
}

Eina_Bool
session_save(Session *session, const char *filename)
{
    Eet_File *ef;
    Eina_Bool ret;

    if (filename) eina_stringshare_replace(&(session->__eet_filename), filename);
    else if (session->__eet_filename) filename = session->__eet_filename;
    else return EINA_FALSE;

    ef = eet_open(filename, EET_FILE_MODE_READ_WRITE);
    if (!ef)
       {
          fprintf(stderr, "ERROR: could not open '%s' for write\n", filename);
          return EINA_FALSE;
       }

    ret = !!eet_data_write(ef, _session_descriptor, SESSION_ENTRY, session, EINA_TRUE);
    eet_close(ef);

    return ret;
}

static inline void
_services_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_services_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Services);
    _services_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_services_descriptor, Services, "id", id, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_services_descriptor, Services, "model", model, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_services_descriptor, Services, "types", types, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_services_descriptor, Services, "icon__id", icon__id, EET_T_UINT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_services_descriptor, Services, "allowed", allowed, EET_T_UCHAR);
}

static inline void
_services_shutdown(void)
{
    if (!_services_descriptor) return;
    eet_data_descriptor_free(_services_descriptor);
    _services_descriptor = NULL;
}

Services *
services_new(const char * id, const char * model, const char * types, Evas_Object * icon, unsigned char allowed)
{
    Services *services = calloc(1, sizeof(Services));

    if (!services)
       {
          fprintf(stderr, "ERROR: could not calloc Services\n");
          return NULL;
       }

    services->id = eina_stringshare_add(id);
    services->model = eina_stringshare_add(model);
    services->types = eina_stringshare_add(types);
    services->icon = icon;
    services->icon__id = 0;
    services->allowed = allowed;

    return services;
}

void
services_free(Services *services)
{
    eina_stringshare_del(services->id);
    eina_stringshare_del(services->model);
    eina_stringshare_del(services->types);
    if (services->icon) evas_object_del(services->icon);
    free(services);
}

static void 
_services_icon_freed(void *data, Evas *e, Evas_Object *obj, void *event_info)
{
    Services *services = data;
    services->icon__id = 0;
    services->icon = NULL;
}

static void
_load_services_images(Services *services, Evas *evas, const char *filename)
{
    Eet_File *ef = eet_open(filename, EET_FILE_MODE_READ);
    if (!ef)
       {
          fprintf(stderr, "ERROR: could not open '%s' for read\n", filename);
          return;
       }

    if (services->icon__id)
       {
          char icon_buf[256];
          unsigned int icon_w, icon_h;
          int icon_alpha, icon_compress, icon_quality, icon_lossy;
          void *icon_data;
          sprintf(icon_buf, "/image/%d", services->icon__id);
          icon_data = eet_data_image_read(ef, icon_buf, &icon_w, &icon_h, &icon_alpha, &icon_compress, &icon_quality, &icon_lossy);
          if (icon_data)
             {
                services->icon = evas_object_image_add(evas);
                evas_object_image_size_set(services->icon, icon_w, icon_h);
                evas_object_image_alpha_set(services->icon, icon_alpha);
                evas_object_image_data_set(services->icon, icon_data);
                evas_object_event_callback_add(services->icon, EVAS_CALLBACK_FREE, _services_icon_freed, services);
             }
       }

    eet_close(ef);
}

static int
_write_services_images(Services *services, Eet_File *ef, int image_id)
{
    if (services->icon)
       {
          char icon_buf[256];
          int icon_w, icon_h;
          int icon_alpha;
          void *icon_data;
          services->icon__id = image_id;
          sprintf(icon_buf, "/image/%d", image_id++);
          evas_object_image_size_get(services->icon, &icon_w, &icon_h);
          icon_alpha = evas_object_image_alpha_get(services->icon);
          icon_data = evas_object_image_data_get(services->icon, EINA_FALSE);
          eet_data_image_write(ef, icon_buf, icon_data, icon_w, icon_h, icon_alpha, 1, 95, 0);
       }
    return image_id;
}

inline const char *
services_id_get(const Services *services)
{
    return services->id;
}

inline void
services_id_set(Services *services, const char *id)
{
    EINA_SAFETY_ON_NULL_RETURN(services);
    eina_stringshare_replace(&(services->id), id);
}

inline const char *
services_model_get(const Services *services)
{
    return services->model;
}

inline void
services_model_set(Services *services, const char *model)
{
    EINA_SAFETY_ON_NULL_RETURN(services);
    eina_stringshare_replace(&(services->model), model);
}

inline const char *
services_types_get(const Services *services)
{
    return services->types;
}

inline void
services_types_set(Services *services, const char *types)
{
    EINA_SAFETY_ON_NULL_RETURN(services);
    eina_stringshare_replace(&(services->types), types);
}

void
services_icon_set(Services *services, Evas_Object *icon)
{
    EINA_SAFETY_ON_NULL_RETURN(services);
    if (services->icon) evas_object_del(services->icon);
    services->icon__id = 0;
    services->icon = icon;
    evas_object_event_callback_add(icon, EVAS_CALLBACK_FREE, _services_icon_freed, services);
}

Evas_Object *
services_icon_get(Services *services, Evas *evas, const char *eet_file)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(services, NULL);
    if (services->icon) return services->icon;
    _load_services_images(services, evas, eet_file);
    return services->icon;
}

inline unsigned char
services_allowed_get(const Services *services)
{
    return services->allowed;
}

inline void
services_allowed_set(Services *services, unsigned char allowed)
{
    EINA_SAFETY_ON_NULL_RETURN(services);
    services->allowed = allowed;
}


static inline void
_device_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_device_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Device);
    _device_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_device_descriptor, Device, "url", url, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_device_descriptor, Device, "friendly_name", friendly_name, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_device_descriptor, Device, "icon__id", icon__id, EET_T_UINT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_device_descriptor, Device, "allowed", allowed, EET_T_UCHAR);
    EET_DATA_DESCRIPTOR_ADD_HASH(_device_descriptor, Device, "services", services, _services_descriptor);
}

static inline void
_device_shutdown(void)
{
    if (!_device_descriptor) return;
    eet_data_descriptor_free(_device_descriptor);
    _device_descriptor = NULL;
}

Device *
device_new(const char * url, const char * friendly_name, Evas_Object * icon, unsigned char allowed)
{
    Device *device = calloc(1, sizeof(Device));

    if (!device)
       {
          fprintf(stderr, "ERROR: could not calloc Device\n");
          return NULL;
       }

    device->url = eina_stringshare_add(url);
    device->friendly_name = eina_stringshare_add(friendly_name);
    device->icon = icon;
    device->icon__id = 0;
    device->allowed = allowed;
    device->services = eina_hash_stringshared_new(EINA_FREE_CB(services_free));

    return device;
}

void
device_free(Device *device)
{
    eina_stringshare_del(device->url);
    eina_stringshare_del(device->friendly_name);
    if (device->icon) evas_object_del(device->icon);
    if (device->services) eina_hash_free(device->services);
    free(device);
}

static void 
_device_icon_freed(void *data, Evas *e, Evas_Object *obj, void *event_info)
{
    Device *device = data;
    device->icon__id = 0;
    device->icon = NULL;
}

static void
_load_device_images(Device *device, Evas *evas, const char *filename)
{
    Eet_File *ef = eet_open(filename, EET_FILE_MODE_READ);
    if (!ef)
       {
          fprintf(stderr, "ERROR: could not open '%s' for read\n", filename);
          return;
       }

    if (device->icon__id)
       {
          char icon_buf[256];
          unsigned int icon_w, icon_h;
          int icon_alpha, icon_compress, icon_quality, icon_lossy;
          void *icon_data;
          sprintf(icon_buf, "/image/%d", device->icon__id);
          icon_data = eet_data_image_read(ef, icon_buf, &icon_w, &icon_h, &icon_alpha, &icon_compress, &icon_quality, &icon_lossy);
          if (icon_data)
             {
                device->icon = evas_object_image_add(evas);
                evas_object_image_size_set(device->icon, icon_w, icon_h);
                evas_object_image_alpha_set(device->icon, icon_alpha);
                evas_object_image_data_set(device->icon, icon_data);
                evas_object_event_callback_add(device->icon, EVAS_CALLBACK_FREE, _device_icon_freed, device);
             }
       }

    eet_close(ef);
}

static int
_write_device_images(Device *device, Eet_File *ef, int image_id)
{
    if (device->icon)
       {
          char icon_buf[256];
          int icon_w, icon_h;
          int icon_alpha;
          void *icon_data;
          device->icon__id = image_id;
          sprintf(icon_buf, "/image/%d", image_id++);
          evas_object_image_size_get(device->icon, &icon_w, &icon_h);
          icon_alpha = evas_object_image_alpha_get(device->icon);
          icon_data = evas_object_image_data_get(device->icon, EINA_FALSE);
          eet_data_image_write(ef, icon_buf, icon_data, icon_w, icon_h, icon_alpha, 1, 95, 0);
       }
    return image_id;
}

inline const char *
device_url_get(const Device *device)
{
    return device->url;
}

inline void
device_url_set(Device *device, const char *url)
{
    EINA_SAFETY_ON_NULL_RETURN(device);
    eina_stringshare_replace(&(device->url), url);
}

inline const char *
device_friendly_name_get(const Device *device)
{
    return device->friendly_name;
}

  inline void
device_friendly_name_set(Device *device, const char *friendly_name)
{
    EINA_SAFETY_ON_NULL_RETURN(device);
    eina_stringshare_replace(&(device->friendly_name), friendly_name);
}

void device_icon_set(Device *device, Evas_Object *icon)
{
    EINA_SAFETY_ON_NULL_RETURN(device);
    if (device->icon) evas_object_del(device->icon);
    device->icon__id = 0;
    device->icon = icon;
    evas_object_event_callback_add(icon, EVAS_CALLBACK_FREE, _device_icon_freed, device);
}

Evas_Object *device_icon_get(Device *device, Evas *evas, const char *eet_file)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(device, NULL);
    if (device->icon) return device->icon;
    _load_device_images(device, evas, eet_file);
    return device->icon;
}

inline unsigned char
device_allowed_get(const Device *device)
{
    return device->allowed;
}

inline void 
device_allowed_set(Device *device, unsigned char allowed)
{
    EINA_SAFETY_ON_NULL_RETURN(device);
    device->allowed = allowed;
}

void
device_services_add(Device *device, const char * id, Services *services)
{
    EINA_SAFETY_ON_NULL_RETURN(device);
    eina_hash_add(device->services, id, services);
}

void
device_services_del(Device *device, const char * id)
{
    EINA_SAFETY_ON_NULL_RETURN(device);
    eina_hash_del(device->services, id, NULL);
}

inline Services *
device_services_get(const Device *device, const char * id)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(device, NULL);
    return eina_hash_find(device->services, id);
}

inline Eina_Hash *
device_services_hash_get(const Device *device)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(device, NULL);
    return device->services;
}

void
device_services_modify(Device *device, const char * key, void *value)
{
    EINA_SAFETY_ON_NULL_RETURN(device);
    eina_hash_modify(device->services, key, value);
}


static inline void
_network_origin_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_network_origin_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Network_Origin);
    _network_origin_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_network_origin_descriptor, Network_Origin, "origin", origin, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_LIST(_network_origin_descriptor, Network_Origin, "devices", devices, _device_descriptor);
    EET_DATA_DESCRIPTOR_ADD_HASH(_network_origin_descriptor, Network_Origin, "services", services, _services_descriptor);
}

static inline void
_network_origin_shutdown(void)
{
    if (!_network_origin_descriptor) return;
    eet_data_descriptor_free(_network_origin_descriptor);
    _network_origin_descriptor = NULL;
}

Network_Origin *
network_origin_new(const char * origin, Eina_List * devices)
{
    Network_Origin *network_origin = calloc(1, sizeof(Network_Origin));

    if (!network_origin)
       {
          fprintf(stderr, "ERROR: could not calloc Network_Origin\n");
          return NULL;
       }

    network_origin->origin = eina_stringshare_add(origin);
    network_origin->devices = devices;
    network_origin->services = eina_hash_stringshared_new(EINA_FREE_CB(services_free));

    return network_origin;
}

void
network_origin_free(Network_Origin *network_origin)
{
    eina_stringshare_del(network_origin->origin);
    if (network_origin->devices)
       {
          Device *devices_elem;
          EINA_LIST_FREE(network_origin->devices, devices_elem)
             device_free(devices_elem);
       }
    free(network_origin);
}

inline const char *
network_origin_origin_get(const Network_Origin *network_origin)
{
    return network_origin->origin;
}

inline void
network_origin_origin_set(Network_Origin *network_origin, const char *origin)
{
    EINA_SAFETY_ON_NULL_RETURN(network_origin);
    eina_stringshare_replace(&(network_origin->origin), origin);
}

void
network_origin_devices_add(Network_Origin *network_origin, Device *device)
{
    EINA_SAFETY_ON_NULL_RETURN(network_origin);
    network_origin->devices = eina_list_append(network_origin->devices, device);
}

void
network_origin_devices_del(Network_Origin *network_origin, Device *device)
{
    EINA_SAFETY_ON_NULL_RETURN(network_origin);
    network_origin->devices = eina_list_remove(network_origin->devices, device);
}

inline Device *
network_origin_devices_get(const Network_Origin *network_origin, unsigned int nth)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(network_origin, NULL);
    return eina_list_nth(network_origin->devices, nth);
}

inline unsigned int
network_origin_devices_count(const Network_Origin *network_origin)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(network_origin, 0);
    return eina_list_count(network_origin->devices);
}

void
network_origin_devices_list_clear(Network_Origin *network_origin)
{
    EINA_SAFETY_ON_NULL_RETURN(network_origin);
    Device *data;
    EINA_LIST_FREE(network_origin->devices, data) device_free(data);
}

inline Eina_List *
network_origin_devices_list_get(const Network_Origin *network_origin)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(network_origin, NULL);
    return network_origin->devices;
}

inline void
network_origin_devices_list_set(Network_Origin *network_origin, Eina_List *list)
{
    EINA_SAFETY_ON_NULL_RETURN(network_origin);
    network_origin->devices = list;
}

void
network_origin_services_add(Network_Origin *network_origin, const char * id, Services *services)
{
    EINA_SAFETY_ON_NULL_RETURN(network_origin);
    eina_hash_add(network_origin->services, id, services);
}

void
network_origin_services_del(Network_Origin *network_origin, const char * id)
{
    EINA_SAFETY_ON_NULL_RETURN(network_origin);
    eina_hash_del(network_origin->services, id, NULL);
}

inline Services *
network_origin_services_get(const Network_Origin *network_origin, const char * id)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(network_origin, NULL);
    return eina_hash_find(network_origin->services, id);
}

inline Eina_Hash *
network_origin_services_hash_get(const Network_Origin *network_origin)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(network_origin, NULL);
    return network_origin->services;
}

void
network_origin_services_modify(Network_Origin *network_origin, const char * key, void *value)
{
    EINA_SAFETY_ON_NULL_RETURN(network_origin);
    eina_hash_modify(network_origin->services, key, value);
}

static inline void
_network_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_network_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Network);
    _network_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_LIST(_network_descriptor, Network, "origins", origins, _network_origin_descriptor);
}

static inline void
_network_shutdown(void)
{
    if (!_network_descriptor) return;
    eet_data_descriptor_free(_network_descriptor);
    _network_descriptor = NULL;
}

Network *
network_new(Eina_List * origins)
{
    Network *network = calloc(1, sizeof(Network));

    if (!network)
       {
          fprintf(stderr, "ERROR: could not calloc Network\n");
          return NULL;
       }

    network->origins = origins;

    return network;
}

void
network_free(Network *network)
{
    if (network->origins)
       {
          Network_Origin *origins_elem;
          EINA_LIST_FREE(network->origins, origins_elem)
             network_origin_free(origins_elem);
       }
    free(network);
}

inline void
network_origins_add(Network *network, Network_Origin *network_origin)
{
    EINA_SAFETY_ON_NULL_RETURN(network);
    network->origins = eina_list_append(network->origins, network_origin);
}

inline void
network_origins_del(Network *network, Network_Origin *network_origin)
{
    EINA_SAFETY_ON_NULL_RETURN(network);
    network->origins = eina_list_remove(network->origins, network_origin);
}

inline Network_Origin *
network_origins_get(const Network *network, unsigned int nth)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(network, NULL);
    return eina_list_nth(network->origins, nth);
}

inline unsigned int
network_origins_count(const Network *network)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(network, 0);
    return eina_list_count(network->origins);
}

void
network_origins_list_clear(Network *network)
{
    EINA_SAFETY_ON_NULL_RETURN(network);
    Network_Origin *data;
    EINA_LIST_FREE(network->origins, data) network_origin_free(data);
}

inline Eina_List *
network_origins_list_get(const Network *network)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(network, NULL);
    return network->origins;
}

inline void
network_origins_list_set(Network *network, Eina_List *list)
{
    EINA_SAFETY_ON_NULL_RETURN(network);
    network->origins = list;
}

Network *
network_load(const char *filename)
{
    Network *network = NULL;
    Eet_File *ef = eet_open(filename, EET_FILE_MODE_READ);
    if (!ef)
      {
        fprintf(stderr, "ERROR: could not open '%s' for read\n", filename);
        return NULL;
      }

    network = eet_data_read(ef, _network_descriptor, NETWORK_ENTRY);
    if (!network) goto end;
    network->__eet_filename = eina_stringshare_add(filename);

end:
    eet_close(ef);
    return network;
}

Eina_Bool
network_save(Network *network, const char *filename)
{
    Eet_File *ef;
    Eina_Bool ret;

    if (filename) eina_stringshare_replace(&(network->__eet_filename), filename);
    else if (network->__eet_filename) filename = network->__eet_filename;
    else return EINA_FALSE;

    ef = eet_open(filename, EET_FILE_MODE_READ_WRITE);
    if (!ef)
       {
          fprintf(stderr, "ERROR: could not open '%s' for write\n", filename);
          return EINA_FALSE;
       }

    if (network->origins)
       {
          Network_Origin *origins;
          Eina_List *origins_list;
          EINA_LIST_FOREACH(network->origins, origins_list, origins)
             {
                 Device *devices;
                 Eina_List *devices_list;

                 EINA_LIST_FOREACH(origins->devices, devices_list, devices)
                    {
                        Eina_Iterator *services_itr = eina_hash_iterator_key_new(devices->services);
                        char *service_id;

                        _images_id = _write_device_images(devices, ef, _images_id);

                        EINA_ITERATOR_FOREACH(services_itr, service_id)
                           {
                               Services *services = device_services_get(devices, service_id);
                               _images_id = _write_services_images(services, ef, _images_id);
                           }
                    }
             }
       }
    
    ret = !!eet_data_write(ef, _network_descriptor, NETWORK_ENTRY, network, EINA_TRUE);
    eet_close(ef);

    return ret;
}

void
eve_state_init(void)
{
    _config_init();
    _hist_item_init();
    _hist_init();
    _fav_item_init();
    _fav_init();
    _session_item_init();
    _session_window_init();
    _session_init();
    _services_init();
    _device_init();
    _network_origin_init();
    _network_init();
}

void
eve_state_shutdown(void)
{
    _config_shutdown();
    _hist_item_shutdown();
    _hist_shutdown();
    _fav_item_shutdown();
    _fav_shutdown();
    _session_item_shutdown();
    _session_window_shutdown();
    _session_shutdown();
    _services_shutdown();
    _device_shutdown();
    _network_origin_shutdown();
    _network_shutdown();
}

